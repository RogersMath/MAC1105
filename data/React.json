[
  {
    "questionId": "REACT001",
    "question": "What is React primarily used for?",
    "answers": [
      "Building user interfaces",
      "Server-side scripting",
      "Database management",
      "Network protocols"
    ],
    "correct": "Building user interfaces",
    "explanation": "React is a JavaScript library primarily used for building user interfaces, especially for single-page applications.",
    "category": "Basics",
    "difficulty": "Easy"
  },
  {
    "questionId": "REACT002",
    "question": "What is the primary advantage of using JSX in React?",
    "answers": [
      "It allows inline styling",
      "It combines markup and logic",
      "It compiles to pure JavaScript",
      "It enforces strict type checking"
    ],
    "correct": "It combines markup and logic",
    "explanation": "JSX allows you to write HTML-like code directly in your JavaScript, combining markup and logic in a single file. This makes components more readable and easier to maintain.",
    "category": "Basics",
    "difficulty": "Easy"
  },
  {
    "questionId": "REACT003",
    "question": "In React, what is a component?",
    "answers": [
      "A reusable piece of UI",
      "A JavaScript function",
      "A CSS stylesheet",
      "An HTML element"
    ],
    "correct": "A reusable piece of UI",
    "explanation": "In React, a component is a reusable piece of UI that can be a function or a class, which returns JSX to describe what should be rendered.",
    "category": "Components",
    "difficulty": "Easy"
  },
  {
    "questionId": "REACT004",
    "question": "How do you typically render a React component?",
    "answers": [
      "Using JSX tags",
      "Calling it as a function",
      "Using HTML tags",
      "Importing it as a module"
    ],
    "correct": "Using JSX tags",
    "explanation": "React components are typically rendered using JSX tags, which look similar to HTML tags but start with a capital letter for custom components.",
    "category": "Components",
    "difficulty": "Easy"
  },
  {
    "questionId": "REACT005",
    "question": "What is the purpose of state in React?",
    "answers": [
      "To store changeable data",
      "To define component structure",
      "To handle HTTP requests",
      "To style components"
    ],
    "correct": "To store changeable data",
    "explanation": "State in React is used to store data that can change over time within a component, triggering re-renders when updated.",
    "category": "State",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT006",
    "question": "Which hook adds state to functional components?",
    "answers": [
      "useState",
      "useEffect",
      "useContext",
      "useReducer"
    ],
    "correct": "useState",
    "explanation": "The useState hook is used to add state to functional components in React, returning the current state and a function to update it.",
    "category": "Hooks",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT007",
    "question": "What does the useEffect hook do?",
    "answers": [
      "Manages side effects",
      "Creates new components",
      "Handles form input",
      "Optimizes rendering"
    ],
    "correct": "Manages side effects",
    "explanation": "The useEffect hook is used to perform side effects in functional components, such as data fetching, subscriptions, or manually changing the DOM.",
    "category": "Hooks",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT008",
    "question": "What is the virtual DOM in React?",
    "answers": [
      "A lightweight copy of the actual DOM",
      "A new web browser feature",
      "A type of JavaScript engine",
      "A React-specific HTML version"
    ],
    "correct": "A lightweight copy of the actual DOM",
    "explanation": "The virtual DOM is a lightweight copy of the actual DOM that React uses to improve performance by minimizing direct manipulation of the real DOM.",
    "category": "Concepts",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT009",
    "question": "What is the main purpose of props in React?",
    "answers": [
      "To pass data between components",
      "To define component methods",
      "To manage global state",
      "To handle DOM events"
    ],
    "correct": "To pass data between components",
    "explanation": "Props (short for properties) are used to pass data from parent components to child components in React, making components more reusable and dynamic.",
    "category": "Components",
    "difficulty": "Easy"
  },
  {
    "questionId": "REACT010",
    "question": "How should you update state in a class component?",
    "answers": [
      "Using setState()",
      "Directly assigning values",
      "Using useState()",
      "Modifying this.state"
    ],
    "correct": "Using setState()",
    "explanation": "In class components, state should be updated using the setState() method to ensure proper re-rendering and to maintain the integrity of the component's lifecycle.",
    "category": "State",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT011",
    "question": "Why use the key prop in lists?",
    "answers": [
      "For efficient updates",
      "To style list items",
      "For accessibility",
      "To sort the list"
    ],
    "correct": "For efficient updates",
    "explanation": "The key prop is used to give elements in a list a stable identity, helping React identify which items have changed, been added, or been removed, improving update efficiency.",
    "category": "Lists",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT012",
    "question": "What is React.Fragment used for?",
    "answers": [
      "Grouping elements",
      "Creating animations",
      "Handling events",
      "Managing state"
    ],
    "correct": "Grouping elements",
    "explanation": "React.Fragment is used to group multiple elements without adding an extra node to the DOM, useful when you need to return multiple elements from a component.",
    "category": "Components",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT013",
    "question": "What does the useContext hook do?",
    "answers": [
      "Consumes context values",
      "Creates new contexts",
      "Manages local state",
      "Handles side effects"
    ],
    "correct": "Consumes context values",
    "explanation": "The useContext hook is used to consume values from the React context without wrapping the component in a Context.Consumer, simplifying the process of accessing context values.",
    "category": "Hooks",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT014",
    "question": "What is the primary use of useRef?",
    "answers": [
      "To access DOM elements",
      "To manage component state",
      "To handle side effects",
      "To optimize rendering"
    ],
    "correct": "To access DOM elements",
    "explanation": "The useRef hook is primarily used to create a mutable reference that persists across re-renders, often used to access DOM elements directly or store any mutable value.",
    "category": "Hooks",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT015",
    "question": "What do PropTypes do in React?",
    "answers": [
      "Validate prop types",
      "Create new props",
      "Handle prop changes",
      "Optimize prop usage"
    ],
    "correct": "Validate prop types",
    "explanation": "PropTypes is a type-checking library for props in React, helping catch bugs by validating the types of props passed to components during development.",
    "category": "Props",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT016",
    "question": "What does the useCallback hook do?",
    "answers": [
      "Memoizes functions",
      "Creates new functions",
      "Manages component lifecycle",
      "Handles asynchronous calls"
    ],
    "correct": "Memoizes functions",
    "explanation": "The useCallback hook is used to memoize callback functions, returning a memoized version of the callback that only changes if one of the dependencies has changed.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT017",
    "question": "What is the purpose of the useMemo hook?",
    "answers": [
      "To optimize expensive calculations",
      "To manage component state",
      "To handle side effects",
      "To create memoized components"
    ],
    "correct": "To optimize expensive calculations",
    "explanation": "The useMemo hook is used to memoize expensive computations so that they are only recalculated when one of their dependencies changes, optimizing performance.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT018",
    "question": "What does React.memo do?",
    "answers": [
      "Memoizes functional components",
      "Creates class components",
      "Manages global state",
      "Handles form submissions"
    ],
    "correct": "Memoizes functional components",
    "explanation": "React.memo is a higher-order component that memoizes functional components to prevent unnecessary re-renders if the props haven't changed.",
    "category": "Performance Optimization",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT019",
    "question": "What is the useReducer hook used for?",
    "answers": [
      "Managing complex state logic",
      "Reducing bundle size",
      "Handling API calls",
      "Creating reusable components"
    ],
    "correct": "Managing complex state logic",
    "explanation": "The useReducer hook is used for managing more complex state logic in components, especially when the next state depends on the previous one.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT020",
    "question": "When should dangerouslySetInnerHTML be used in React?",
    "answers": [
      "Never, it's always unsafe",
      "For dynamic HTML content",
      "Only with sanitized data",
      "To improve performance"
    ],
    "correct": "Only with sanitized data",
    "explanation": "dangerouslySetInnerHTML should only be used with properly sanitized data to prevent XSS attacks. It's useful for setting HTML directly, but requires careful handling.",
    "category": "Security",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT021",
    "question": "What does the StrictMode component do?",
    "answers": [
      "Identifies potential issues",
      "Enforces type checking",
      "Improves performance",
      "Manages application state"
    ],
    "correct": "Identifies potential issues",
    "explanation": "StrictMode is a tool for highlighting potential problems in a React application by activating additional checks and warnings for its descendants.",
    "category": "Development Tools",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT022",
    "question": "What is the purpose of the key prop?",
    "answers": [
      "To uniquely identify elements",
      "To encrypt component data",
      "To define component styles",
      "To handle user interactions"
    ],
    "correct": "To uniquely identify elements",
    "explanation": "The key prop is used to give elements in a list a stable identity, helping React identify which items have changed, been added, or been removed.",
    "category": "Lists",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT023",
    "question": "What does the useLayoutEffect hook do?",
    "answers": [
      "Runs synchronously after DOM updates",
      "Manages component layout",
      "Handles responsive design",
      "Optimizes state updates"
    ],
    "correct": "Runs synchronously after DOM updates",
    "explanation": "useLayoutEffect runs synchronously after all DOM mutations, useful for DOM measurements and mutations that need to happen before the browser repaints.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT024",
    "question": "What is the purpose of forwardRef?",
    "answers": [
      "To pass refs to child components",
      "To create new refs",
      "To optimize ref usage",
      "To handle form submissions"
    ],
    "correct": "To pass refs to child components",
    "explanation": "forwardRef is used to pass a ref through a component to one of its children, allowing parent components to directly interact with a child element or component.",
    "category": "Advanced Concepts",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT025",
    "question": "What does useImperativeHandle do?",
    "answers": [
      "Customizes the exposed instance value",
      "Handles imperative code",
      "Creates class components",
      "Manages component state"
    ],
    "correct": "Customizes the exposed instance value",
    "explanation": "useImperativeHandle customizes the instance value that is exposed when using ref, allowing parent components to interact with specific methods or properties of a child component.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT026",
    "question": "What are Error Boundaries in React?",
    "answers": [
      "Components that catch errors",
      "Built-in error handling functions",
      "Special try-catch blocks",
      "Error logging services"
    ],
    "correct": "Components that catch errors",
    "explanation": "Error Boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed.",
    "category": "Error Handling",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT027",
    "question": "What does React.lazy() do?",
    "answers": [
      "Enables dynamic imports",
      "Creates lazy-loaded images",
      "Optimizes component rendering",
      "Manages asynchronous state"
    ],
    "correct": "Enables dynamic imports",
    "explanation": "React.lazy() function lets you render a dynamic import as a regular component, allowing you to split your code and load components only when they're needed.",
    "category": "Performance Optimization",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT028",
    "question": "What is the Suspense component used for?",
    "answers": [
      "Showing fallback content",
      "Creating suspenseful animations",
      "Handling asynchronous operations",
      "Managing loading states"
    ],
    "correct": "Showing fallback content",
    "explanation": "The Suspense component lets you specify fallback content (like a loading indicator) to show while waiting for lazy-loaded components to load.",
    "category": "Advanced Concepts",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT033",
    "question": "What is the main purpose of React's PureComponent?",
    "answers": [
      "To implement shallow prop and state comparison",
      "To create components with pure functions",
      "To eliminate side effects in components",
      "To automatically optimize all components"
    ],
    "correct": "To implement shallow prop and state comparison",
    "explanation": "React.PureComponent implements shouldComponentUpdate() with a shallow prop and state comparison, potentially boosting performance by reducing unnecessary renders.",
    "category": "Performance Optimization",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT034",
    "question": "What is a common use case for the useReducer hook?",
    "answers": [
      "Simple state updates",
      "Complex state logic",
      "Component styling",
      "Handling form inputs"
    ],
    "correct": "Complex state logic",
    "explanation": "useReducer is often used for managing more complex state logic in components, especially when the next state depends on the previous one.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT035",
    "question": "What is the purpose of React.createRef()?",
    "answers": [
      "To create a ref object",
      "To render new elements",
      "To clone components",
      "To create contexts"
    ],
    "correct": "To create a ref object",
    "explanation": "React.createRef() is used to create a ref that can be attached to React elements via the ref attribute, allowing access to the DOM node or React element instance.",
    "category": "Refs",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT036",
    "question": "What does getDerivedStateFromProps do?",
    "answers": [
      "Updates state based on props",
      "Fetches data from APIs",
      "Initializes component state",
      "Handles prop type checking"
    ],
    "correct": "Updates state based on props",
    "explanation": "getDerivedStateFromProps is a static method invoked right before calling the render method, both on the initial mount and on subsequent updates. It can be used to update the state based on changes in props.",
    "category": "Lifecycle Methods",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT037",
    "question": "What is the purpose of componentDidCatch?",
    "answers": [
      "Handles errors in child components",
      "Catches network request errors",
      "Debugs render method errors",
      "Manages asynchronous errors"
    ],
    "correct": "Handles errors in child components",
    "explanation": "componentDidCatch is a lifecycle method used in class components to catch errors in their child component tree, allowing components to log error information and display a fallback UI.",
    "category": "Error Handling",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT038",
    "question": "What does React.cloneElement() do?",
    "answers": [
      "Clones and returns a new element",
      "Duplicates entire components",
      "Creates deep copies of objects",
      "Replicates the DOM structure"
    ],
    "correct": "Clones and returns a new element",
    "explanation": "React.cloneElement() is used to clone and return a new React element using an existing element as the starting point, often used to extend or modify the props of child elements.",
    "category": "Advanced Concepts",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT039",
    "question": "What is the purpose of React.Children.map()?",
    "answers": [
      "To iterate over child components",
      "To create arrays from components",
      "To filter child elements",
      "To transform the component tree"
    ],
    "correct": "To iterate over child components",
    "explanation": "React.Children.map() is used to iterate over and potentially transform child components. It's particularly useful when you need to manipulate or augment the children passed to a component.",
    "category": "Advanced Concepts",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT040",
    "question": "What does React.Children.only() do?",
    "answers": [
      "Ensures a single child element",
      "Selects the first child",
      "Removes extra children",
      "Validates child types"
    ],
    "correct": "Ensures a single child element",
    "explanation": "React.Children.only() verifies that children has only one child (a React element) and returns it. Otherwise, it throws an error. It's used to enforce that a component has only one child element.",
    "category": "Advanced Concepts",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT041",
    "question": "What is the main use of useImperativeHandle?",
    "answers": [
      "Customizes ref exposed value",
      "Handles imperative logic",
      "Creates mutable references",
      "Optimizes child rendering"
    ],
    "correct": "Customizes ref exposed value",
    "explanation": "useImperativeHandle customizes the instance value that is exposed to parent components when using ref. It should be used with forwardRef to give parent components access to specific functions or values of a child component.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT042",
    "question": "What is the primary purpose of useMemo?",
    "answers": [
      "Memoizes computed values",
      "Creates memoized components",
      "Optimizes hook performance",
      "Caches function results"
    ],
    "correct": "Memoizes computed values",
    "explanation": "useMemo is used to memoize computed values so that they are only recalculated when one of their dependencies changes. This can help to optimize performance by avoiding unnecessary calculations on every render.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT043",
    "question": "What does the useCallback hook do?",
    "answers": [
      "Memoizes callback functions",
      "Creates new callbacks",
      "Optimizes all functions",
      "Manages callback queues"
    ],
    "correct": "Memoizes callback functions",
    "explanation": "useCallback returns a memoized version of the callback function that only changes if one of the dependencies has changed. It's useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT044",
    "question": "What are two primary uses of the useRef hook?",
    "answers": [
      "Styling and animation",
      "State management and props",
      "DOM access and mutable values",
      "Event handling and lifecycle"
    ],
    "correct": "DOM access and mutable values",
    "explanation": "useRef is commonly used for accessing DOM elements directly and for keeping mutable values that don't require re-rendering when they change.",
    "category": "Hooks",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT045",
    "question": "What does useLayoutEffect do?",
    "answers": [
      "Runs synchronously after DOM mutations",
      "Manages component layouts",
      "Handles side effects asynchronously",
      "Optimizes CSS calculations"
    ],
    "correct": "Runs synchronously after DOM mutations",
    "explanation": "useLayoutEffect is similar to useEffect, but it fires synchronously after all DOM mutations. It's useful for performing DOM measurements and mutations that need to be done before the browser repaints.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT046",
    "question": "What is the purpose of React.createContext()?",
    "answers": [
      "Creates a Context object",
      "Generates new components",
      "Initializes global state",
      "Sets up event listeners"
    ],
    "correct": "Creates a Context object",
    "explanation": "React.createContext() is used to create a Context object. Context provides a way to pass data through the component tree without having to pass props down manually at every level.",
    "category": "Context",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT047",
    "question": "What does the useContext hook do?",
    "answers": [
      "Consumes context values",
      "Creates new contexts",
      "Provides context to children",
      "Manages multiple contexts"
    ],
    "correct": "Consumes context values",
    "explanation": "The useContext hook is used to consume values from a Context object. It allows functional components to subscribe to a context without introducing nesting.",
    "category": "Hooks",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT048",
    "question": "What is the primary benefit of the virtual DOM?",
    "answers": [
      "Improves performance",
      "Enhances security",
      "Simplifies coding",
      "Enables server-side rendering"
    ],
    "correct": "Improves performance",
    "explanation": "The virtual DOM improves performance by minimizing direct manipulation of the actual DOM. React uses it to optimize rendering by batching DOM updates and reducing expensive DOM operations.",
    "category": "Core Concepts",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT049",
    "question": "What is the purpose of the useState hook?",
    "answers": [
      "Add state to function components",
      "Replace class components entirely",
      "Manage global application state",
      "Create stateful higher-order components"
    ],
    "correct": "Add state to function components",
    "explanation": "useState allows you to add state to functional components in React, providing a way to use state without writing a class.",
    "category": "Hooks",
    "difficulty": "Easy"
  },
  {
    "questionId": "REACT050",
    "question": "How does JSX differ from HTML?",
    "answers": [
      "JSX uses camelCase",
      "HTML is more verbose",
      "JSX requires a transpiler",
      "HTML is not component-based"
    ],
    "correct": "JSX uses camelCase",
    "explanation": "Unlike HTML, JSX uses camelCase for attribute names (e.g., onClick instead of onclick) and requires a JavaScript transpiler to convert it into regular JavaScript.",
    "category": "Basics",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT051",
    "question": "What is a higher-order component (HOC) in React?",
    "answers": [
      "A function that takes a component and returns a new one",
      "A component that renders other components",
      "A component with complex state management",
      "A function that generates multiple components"
    ],
    "correct": "A function that takes a component and returns a new one",
    "explanation": "A higher-order component is a function that takes a component and returns a new component, typically adding additional functionality or props.",
    "category": "Advanced Concepts",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT052",
    "question": "What is the purpose of the key prop in React lists?",
    "answers": [
      "Help identify which items changed",
      "Provide a unique CSS selector for each item",
      "Enable list item drag-and-drop functionality",
      "Automatically sort the list items alphabetically"
    ],
    "correct": "Help identify which items changed",
    "explanation": "The key prop helps React identify which items in a list have changed, been added, or been removed, which is crucial for efficient updating of the user interface.",
    "category": "Basics",
    "difficulty": "Easy"
  },
  {
    "questionId": "REACT053",
    "question": "What is the purpose of React.memo?",
    "answers": [
      "Optimize functional components",
      "Create memoized values within a component",
      "Handle memoization of props in class components",
      "Automatically memoize all components in an application"
    ],
    "correct": "Optimize functional components",
    "explanation": "React.memo is a higher-order component that can wrap functional components to optimize performance by memoizing the rendered output and skipping unnecessary re-renders.",
    "category": "Performance Optimization",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT054",
    "question": "What does the useReducer hook do?",
    "answers": [
      "Manage complex state logic",
      "Reduce the bundle size of React applications",
      "Combine multiple components into one",
      "Automatically optimize state updates for performance"
    ],
    "correct": "Manage complex state logic",
    "explanation": "useReducer is a hook that manages complex state logic in React applications. It's an alternative to useState when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT055",
    "question": "What is the purpose of the useEffect hook?",
    "answers": [
      "Perform side effects",
      "Define component layouts",
      "Create global state management",
      "Automatically optimize rendering performance"
    ],
    "correct": "Perform side effects",
    "explanation": "The useEffect hook allows you to perform side effects in function components. It serves the same purpose as componentDidMount, componentDidUpdate, and componentWillUnmount in React class components.",
    "category": "Hooks",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT056",
    "question": "What is the purpose of React portals?",
    "answers": [
      "Render children outside the DOM hierarchy",
      "Create reusable component templates",
      "Manage state across multiple components",
      "Optimize the rendering of large lists of elements"
    ],
    "correct": "Render children outside the DOM hierarchy",
    "explanation": "React portals provide a way to render children into a DOM node that exists outside the DOM hierarchy of the parent component, useful for modals, tooltips, etc.",
    "category": "Advanced Concepts",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT057",
    "question": "What is the purpose of the useContext hook?",
    "answers": [
      "Consume context values",
      "Create new context objects",
      "Manage local component state",
      "Optimize context provider performance"
    ],
    "correct": "Consume context values",
    "explanation": "The useContext hook allows functional components to subscribe to a React context without introducing nesting. It provides a way to pass data through the component tree without manually passing props.",
    "category": "Hooks",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT058",
    "question": "What is the purpose of the dangerouslySetInnerHTML attribute?",
    "answers": [
      "Set HTML directly",
      "Optimize rendering of HTML content",
      "Sanitize user-generated HTML input",
      "Create cross-site scripting vulnerabilities"
    ],
    "correct": "Set HTML directly",
    "explanation": "dangerouslySetInnerHTML is React's replacement for using innerHTML in the browser DOM. It allows you to set HTML directly from React, but its use is discouraged due to potential security risks.",
    "category": "DOM Manipulation",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT059",
    "question": "What is the purpose of the useMemo hook?",
    "answers": [
      "Memoize expensive computations",
      "Create memoized components",
      "Optimize all function calls in a component",
      "Automatically memoize all values in React applications"
    ],
    "correct": "Memoize expensive computations",
    "explanation": "useMemo is a hook that memoizes expensive computations so that they are only recalculated when one of their dependencies changes, helping to optimize performance.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT060",
    "question": "What is the purpose of the useCallback hook?",
    "answers": [
      "Memoize functions",
      "Create callback functions",
      "Handle all callbacks in a component",
      "Automatically optimize all functions for performance"
    ],
    "correct": "Memoize functions",
    "explanation": "useCallback returns a memoized version of the callback function that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT061",
    "question": "What is the purpose of the useRef hook?",
    "answers": [
      "Store mutable values",
      "Replace all uses of this in functional components",
      "Automatically handle references to DOM elements",
      "Create references to other React components"
    ],
    "correct": "Store mutable values",
    "explanation": "useRef returns a mutable ref object whose .current property is initialized to the passed argument. It can be used to store a mutable value that does not cause a re-render when updated.",
    "category": "Hooks",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT062",
    "question": "What's an advantage of using React.Fragment over a div?",
    "answers": [
      "It's faster to render",
      "It doesn't create extra DOM nodes",
      "It allows more nesting",
      "It provides additional props"
    ],
    "correct": "It doesn't create extra DOM nodes",
    "explanation": "React.Fragment lets you group elements without adding an extra node to the DOM, which can be beneficial for styling, accessibility, and keeping the DOM structure clean.",
    "category": "Components",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT063",
    "question": "What is the purpose of the StrictMode component in React?",
    "answers": [
      "Identify potential issues",
      "Enforce strict typing in components",
      "Automatically fix common React anti-patterns",
      "Enable all strict mode checks in JavaScript"
    ],
    "correct": "Identify potential issues",
    "explanation": "StrictMode is a tool for highlighting potential problems in an application. It activates additional checks and warnings for its descendants, helping developers identify issues during development.",
    "category": "Development Tools",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT064",
    "question": "What is the purpose of the useLayoutEffect hook?",
    "answers": [
      "Run effects synchronously",
      "Manage component layouts",
      "Optimize the layout phase of rendering",
      "Automatically handle all DOM measurements"
    ],
    "correct": "Run effects synchronously",
    "explanation": "useLayoutEffect is similar to useEffect, but it fires synchronously after all DOM mutations. It's useful for performing DOM measurements and mutations that need to be done before the browser repaints.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT065",
    "question": "What is the purpose of the useImperativeHandle hook?",
    "answers": [
      "Customize ref value",
      "Handle DOM imperatively",
      "Expose specific methods to parent components",
      "Create mutable object references"
    ],
    "correct": "Expose specific methods to parent components",
    "explanation": "useImperativeHandle customizes the instance value that is exposed to parent components when using ref. It's used to expose specific methods of a child component to its parent.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT066",
    "question": "What is the main purpose of React.lazy()?",
    "answers": [
      "Optimize images",
      "Enable code splitting",
      "Lazy load components",
      "Defer component mounting"
    ],
    "correct": "Lazy load components",
    "explanation": "React.lazy() lets you define a component that is loaded dynamically. It helps in code splitting by allowing you to render a dynamic import as a regular component.",
    "category": "Performance Optimization",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT067",
    "question": "What does the Suspense component do?",
    "answers": [
      "Handle errors",
      "Show a fallback while content loads",
      "Suspend component rendering",
      "Manage asynchronous operations"
    ],
    "correct": "Show a fallback while content loads",
    "explanation": "The Suspense component lets you specify fallback content (like a loading spinner) to show while waiting for lazy-loaded components to load.",
    "category": "Advanced Concepts",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT068",
    "question": "What is the purpose of the useTransition hook?",
    "answers": [
      "Create CSS transitions",
      "Manage route transitions",
      "Prioritize state updates",
      "Handle component mounting transitions"
    ],
    "correct": "Prioritize state updates",
    "explanation": "useTransition allows you to mark some state updates as transitions, which are considered less urgent and can be interrupted by more urgent updates.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT069",
    "question": "What does the useDeferredValue hook do?",
    "answers": [
      "Cache values",
      "Defer state updates",
      "Manage async values",
      "Optimize expensive calculations"
    ],
    "correct": "Defer state updates",
    "explanation": "useDeferredValue lets you defer updating a part of the UI. It's useful for keeping the interface responsive when you have expensive computations.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT070",
    "question": "What is the purpose of the key prop in reconciliation?",
    "answers": [
      "Style elements",
      "Identify changed items",
      "Enable element selection",
      "Optimize rendering performance"
    ],
    "correct": "Identify changed items",
    "explanation": "The key prop is used by React to identify which items have changed, been added, or been removed in lists. It plays a crucial role in the reconciliation process.",
    "category": "Core Concepts",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT071",
    "question": "What is the main use of React.Children utilities?",
    "answers": [
      "Create child components",
      "Clone components",
      "Manipulate children props",
      "Render optimized lists"
    ],
    "correct": "Manipulate children props",
    "explanation": "React.Children provides utilities for dealing with the props.children opaque data structure, allowing you to manipulate and transform child components.",
    "category": "Advanced Concepts",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT072",
    "question": "What is the purpose of the useDebugValue hook?",
    "answers": [
      "Debug components",
      "Log errors",
      "Display custom labels for hooks",
      "Optimize debug performance"
    ],
    "correct": "Display custom labels for hooks",
    "explanation": "useDebugValue can be used to display a label for custom hooks in React DevTools, which can be helpful when debugging an application.",
    "category": "Hooks",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT073",
    "question": "What does the shouldComponentUpdate method do?",
    "answers": [
      "Force updates",
      "Prevent unnecessary renders",
      "Handle component errors",
      "Manage component state"
    ],
    "correct": "Prevent unnecessary renders",
    "explanation": "shouldComponentUpdate is used to let React know if a component's output is not affected by the current change in state or props, potentially preventing unnecessary renders.",
    "category": "Lifecycle Methods",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT074",
    "question": "What is the purpose of the getDerivedStateFromProps method?",
    "answers": [
      "Initialize state",
      "Update state from props",
      "Replace componentWillReceiveProps",
      "Handle prop type checking"
    ],
    "correct": "Update state from props",
    "explanation": "getDerivedStateFromProps is used to update the state of a component based on changes in props. It's called right before calling the render method, both on the initial mount and on subsequent updates.",
    "category": "Lifecycle Methods",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT075",
    "question": "What problem does React's Context API primarily solve?",
    "answers": [
      "Global state management",
      "Prop drilling",
      "Component composition",
      "Code splitting"
    ],
    "correct": "Prop drilling",
    "explanation": "The Context API primarily solves the problem of prop drilling by providing a way to pass data through the component tree without having to pass props down manually at every level.",
    "category": "State Management",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT076",
    "question": "What does the useId hook do?",
    "answers": [
      "Generate unique IDs",
      "Identify components",
      "Create stable IDs for accessibility",
      "Manage component keys"
    ],
    "correct": "Create stable IDs for accessibility",
    "explanation": "useId is a hook for generating unique IDs that are stable across the server and client, helping with accessibility attributes that require unique IDs.",
    "category": "Hooks",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT077",
    "question": "What is the purpose of React's StrictMode?",
    "answers": [
      "Enforce best practices",
      "Highlight potential problems",
      "Enable strict typing",
      "Improve runtime performance"
    ],
    "correct": "Highlight potential problems",
    "explanation": "StrictMode is a tool for highlighting potential problems in an application. It activates additional checks and warnings for its descendants.",
    "category": "Development Tools",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT078",
    "question": "What is the main benefit of using TypeScript with React?",
    "answers": [
      "Faster runtime",
      "Smaller bundle sizes",
      "Enhanced type checking",
      "Automatic optimization"
    ],
    "correct": "Enhanced type checking",
    "explanation": "TypeScript provides static typing to JavaScript, offering enhanced type checking in React applications. This can catch errors early in development and improve code quality.",
    "category": "Development Tools",
    "difficulty": "Medium"
  },
  {
    "questionId": "REACT079",
    "question": "What is the purpose of the useLayoutEffect hook?",
    "answers": [
      "Optimize layouts",
      "Synchronous side effects",
      "Manage component lifecycles",
      "Handle DOM measurements"
    ],
    "correct": "Synchronous side effects",
    "explanation": "useLayoutEffect is similar to useEffect, but it fires synchronously after all DOM mutations. It's useful for performing DOM measurements and mutations synchronously before the browser paints.",
    "category": "Hooks",
    "difficulty": "Hard"
  },
  {
    "questionId": "REACT080",
    "question": "What is the main purpose of React's Profiler component?",
    "answers": [
      "Debug code",
      "Measure render performance",
      "Optimize components",
      "Analyze component structure"
    ],
    "correct": "Measure render performance",
    "explanation": "The Profiler component measures how often a React application renders and what the cost of rendering is. It's used to identify parts of an application that are slow and may benefit from optimization.",
    "category": "Performance Optimization",
    "difficulty": "Hard"
  }
  
  
]
